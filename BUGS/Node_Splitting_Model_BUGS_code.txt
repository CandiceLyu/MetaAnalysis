# 2. Node-splitting Model

# Model specification
model{
# Loop through all trials
for (i in 1:33){
		# Log of the baseline probability
		mu[i] <- log(p[i, 1])
		# Vague prior for the baseline probability
		p[i, 1] ~ dunif(0, 1)
		# Loop through the two interventions
		for (k in 1:2){
				# Binomial likelihood
				r[i, k] ~ dbin(p[i, k], n[i, k])
				# Expected number of events
				rhat[i, k] <- p[i, k] * n[i, k]
				# Deviance contribution of each observation
				dev[i, k] <- 2 * (r[i, k] * (log(r[i, k]) - log(rhat[i, k])) 
						+ (n[i, k] - r[i, k]) * (log(n[i, k] - r[i, k]) - log(n[i, k] - rhat[i, k])))	
				}
		}
										
# Model for effect 0 => 1 (trials 1 to 15)
for (i in 1:15){
		 # Probability of events in intervention group 2 on the log scale
		 log(p[i, 2]) <- mu[i] + min(delta[i], -mu[i])
		 # 0 => 1 trial-specific effect with a normal prior
		 delta[i] ~ dnorm(d[1], tau)
		}
# Vague prior for mean 0 => 1 effect
d[1] ~ dnorm(0, 0.001)

# Priors for standard deviation and precision
# Half-normal prior for SD
sd ~ dnorm(0, prec) I(0, ) 
# Precision for the half-normal prior
prec <- pow(0.32, -2)
# Precision for the normal distribution of delta[i]
tau <- pow(sd, -2)

# Model for effect 1 => 2 (trials 16 to 20)
for (i in 16:20){
		 log(p[i, 2]) <- mu[i] + min(d[2], -mu[i])
		}
# Vague prior for 1 => 2 effect
d[2] ~ dnorm(0, 0.001)

# Model for effect 2 => 3 (trials 21 to 23)
for (i in 21:23){
		 log(p[i, 2]) <- mu[i] + min(d[3], -mu[i])
		}
# Vague prior for 2 => 3 effect
d[3] ~ dnorm(0, 0.001)									
	
# Model for effect 3 => 4 (trials 24 to 26)
for (i in 24:26){
		 log(p[i, 2]) <- mu[i] + min(d[4], -mu[i])
		}
# Vague prior for 3 => 4 effect
d[4] ~ dnorm(0, 0.001)					

# Model for effect 4 => 5 (trials 27 to 28)
for (i in 27:28){
		 log(p[i, 2]) <- mu[i] + min(d[5], -mu[i])
		}
# Vague prior for 4 => 5 effect
d[5] ~ dnorm(0, 0.001)

# Model for effect 0 => 3 (trial 29)
for (i in 29:29){
		 log(p[i, 2]) <- mu[i] + min(delta2[i], -mu[i])
		 delta2[i] ~ dnorm(d[6], tau)
		}
# Direct 0 => 3 effect
d[6] ~ dnorm(0, 0.0001)
# Indirect 0 => 3 effect through 0 => 1 => 2 => 3
d[7] <- d[1] + d[2] + d[3]
# Checking for conflict between direct and indirect effects
# Direct 0 => 3 - Indirect 0 => 3
p.xval1 <- step(d[6] - d[7])
		
# Model for effect 1 => 3 (trials 30 to 31)
for (i in 30:31){
		 log(p[i, 2]) <- mu[i] + min(delta3[i], -mu[i])
		 delta3[i] ~ dnorm(d[8], tau)
		}
# Direct 1 => 3 effect
d[8] ~ dnorm(0, 0.0001)
# Indirect 1 => 3 effect through 1 => 2 => 3
d[9] <- d[2] + d[3]
# Checking for conflict between direct and indirect effects
# Direct 1 => 3 - Indirect 1 => 3
p.xval2 <- step(d[8] - d[9])
							
# Model for effect 1 => 4 (trial 32)
for (i in 32:32){
		 log(p[i, 2]) <- mu[i] + min(delta4[i], -mu[i])
		 delta4[i] ~ dnorm(d[10], tau)
		}
# Direct 1 => 4 effect
d[10] ~ dnorm(0, 0.0001)
# Indirect 1 => 4 effect through 1 => 2 => 3 => 4
d[11] <- d[2] + d[3] + d[4]
# Checking for conflict between direct and indirect effects
# Direct 1 => 4 - Indirect 1 => 4
p.xval3 <- step(d[10] - d[11])
															
# Model for effect 3 => 5 (trial 33)
for (i in 33:33){
		 log(p[i, 2]) <- mu[i] + min(delta5[i], -mu[i])
		 delta5[i] ~ dnorm(d[12], tau)
		}
# Direct 3 => 5 effect
d[12] ~ dnorm(0, 0.0001)
# Indirect 3 => 5 effect through 3 => 4 => 5
d[13] <- d[4] + d[5]
# Checking for conflict between direct and indirect effects
# Direct 3 => 5 - Indirect 3 => 5
p.xval4 <- step(d[12] - d[13])

# Total residual deviance (for model diagnostics)
totresdev <- sum(dev[ , ])

# Calculate Relative Risks (RR)
for (j in 1:13){
		 # Log RR for each effect
		 log(rr[j]) <- d[j]
		}
}
